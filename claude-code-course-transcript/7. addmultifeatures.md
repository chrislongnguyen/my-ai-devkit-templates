You can open multiple sessions with Claude
0:04
Code to work on many features in parallel.
0:08
To manage these sessions and make sure you're not
0:11
overwriting the same file, you can use Git worktrees.
0:14
So let's add Git worktrees to add
0:16
three features to the chatbot in parallel.
0:19
I'll see you there. So I'm going to hop back into Claude.
0:21
And as we saw earlier, Claude Code comes built in
0:24
with quite a few slash commands.
0:27
But you can also make your
0:28
own. To make your own custom commands,
0:29
inside of the dot claude folder.
0:32
Let's make a new folder called commands.
0:34
And inside of here, we're going to make a markdown file
0:38
with the name of the command that we'd like.
0:40
The command here that I'm going to make is called implement feature.
0:44
So I'll create a markdown file called implement-feature.md
0:48
Inside here, I can place whatever I'd like.
0:51
But what I want to show you that's very special
0:54
is if you have any arguments you
0:56
want to pass to your custom command, you can reference it using
1:01
this $ARGUMENTS variable.
1:03
So what I'm asking for here
1:04
is that when this command is used,
1:06
I'll be specifying that you're implementing a new feature.
1:09
The user can then specify whatever that feature is,
1:13
and then I want to make
1:14
sure that Claude Code is well aware
1:15
to only do this for front-end features,
1:18
and to write the changes made to a file called frontend-changes.md
1:22
You can imagine there are many different use cases for custom commands,
1:26
certain ways you want to run tests or run files.
1:29
and anything that you put in here
1:31
does not automatically get added to your context,
1:34
unlike a CLAUDE.md
1:36
So if you want something to be applied
1:39
to every single instance of Claude Code that you make,
1:42
use your CLAUDE.md file.
1:44
But if you just have specific commands
1:46
that you may or may not use across different conversations,
1:50
right here is a great place to put them.
1:52
I'm going to be using this custom command
1:54
when I start talking about worktrees.
1:56
But before we do that, let's quit out of Claude Code,
1:59
hop back in and just verify
2:01
that we can see that custom command.
2:04
And here, I see implement feature, and I see the description
2:07
is coming from the first part of this markdown file.
2:10
Now that I've added this custom command,
2:13
let's go ahead and add and commit it.
2:15
I could do this from the command line,
2:17
but I'm actually going to ask Claude to do that for me.
2:20
Add and commit changes made.
2:22
This is nice so that Claude Code can create
2:24
a nice commit message
2:26
with some descriptive information for what was done.
2:29
We'll see that it's adding the .claude folder
2:31
and committing with the commands necessary.
2:34
We can see here that this has been added to the repository.
2:37
And since we've granted permissions for this already,
2:40
we don't have to respond again.
2:42
If you're ever curious where that lives,
2:44
inside of the claude folder,
2:46
there is a settings.local.json file
2:49
Inside of this file, we can specify
2:52
what commands we've allowed so that we don't need
2:54
to confirm every single time.
2:57
As you can see here, as well,
2:58
when we use playwright, we gave permissions.
3:00
And if you'd like to add your own,
3:02
you can easily do so in this file,
3:04
or even with the handy /permissions command.
3:08
Now that we've got that custom command set up,
3:10
let's talk a little bit about how we
3:12
might want to work in parallel with Claude Code.
3:14
Instead of just opening up multiple terminal
3:17
windows and working directly on this code base,
3:20
we're going to use Git to make sure
3:23
that we don't overwrite existing files when we have
3:27
multiple instances of Claude Code.
3:29
I might have two different instances of
3:31
Claude Code operating on the same file.
3:34
And if I do that with
3:35
the environment that I'm in right now,
3:37
there's going to be overwriting, bug
3:39
creation and quite a bit of confusion.
3:42
Thankfully, Git has an excellent option here
3:44
to use a feature called worktrees.
3:46
And worktrees allow me to essentially create copies of the codebase,
3:51
operate in isolation,
3:53
and then at the end, merge those in together. And in fact,
3:57
I can use Claude to help with that merging
4:00
and management of my worktrees.
4:02
To get started with worktrees,
4:03
I'm going to first make a folder called .trees
4:06
And inside of this worktrees folder,
4:09
I'm going to go ahead and add a couple worktrees.
4:12
Let's add a work tree using the Git worktree add command.
4:15
and then we'll specify the folder as well
4:19
as the name of the work tree that I want to add.
4:21
We'll call this one ui_feature. We'll
4:23
then go ahead and add another one
4:26
called testing_feature,
4:27
and then finally a third one called quality_feature.
4:31
To confirm I've created all of these, I can take a look
4:35
and I can see that I'm on the main branch currently
4:37
and that I've created three separate worktrees.
4:40
To set up correctly in each of these environments,
4:43
I'm going to open up the trees folder,
4:46
and I'm going to open up
4:47
a terminal for each one of them.
4:49
I'll start with my ui_feature and bring that over here.
4:53
I'll then go ahead, bring in my testing feature,
4:55
and I'll move that right to the side.
4:57
Finally, let's bring in our quality_feature.
4:59
Go ahead, bring that over up here.
5:02
To give us a little more
5:04
room, we'll make this a bit smaller.
5:05
And now we have three dedicated terminal windows.
5:08
And we'll hide the explorer as well.
5:10
Now, let's open up Claude for each one of these environments.
5:14
What we can do now is run Claude Code in parallel and
5:18
make sure that if the same files are modified, we're not overwriting
5:23
and we can fix that later
5:24
when we merge in these worktrees.
5:26
I'm going to use this implement-feature command.
5:29
And then I'm going to put in
5:31
a particular feature that I'd like here.
5:33
And that feature allows me to add a
5:36
toggle button to switch between dark and light themes.
5:38
So let's go ahead and create a toggle button, position it,
5:42
and make sure that I can navigate for this particular toggle button.
5:46
We'll start with this part and
5:47
then add in the light theme variant.
5:49
While this is running, I can now move to another work tree.
5:53
And in this second work tree, let's start thinking
5:55
a little bit about what I
5:57
want to do for this testing framework.
5:58
going to pass in a prompt here to enhance
6:01
the existing testing framework and add additional tests for FastAPI endpoints.
6:06
While that's going, let's add some essential
6:08
code quality tools to our development workflow.
6:11
As we do this, we can start
6:13
to see that changes are being requested.
6:15
So let's go ahead and shift between these
6:17
environments and confirm the changes that
6:19
we want. Our tests are being written
6:21
and our additional development dependencies for analyzing
6:25
code base structure and formatting are being added as well.
6:28
What we're going to see here
6:30
is that we're modifying a file called pyproject.toml
6:33
And we're also going to see that there's a request being added
6:37
to edit that particular file as well.
6:40
As we continue these options
6:42
will make edits to these files,
6:44
and we'll go ahead and see at the same time
6:46
that our front end code is being done as expected.
6:48
We can work in parallel and make sure
6:51
that none of these particular changes are being overwritten by
6:55
other parts of the codebase. If there happen
6:57
to be changes that we've made to similar files,
6:59
we can ensure that those merge conflicts are fixed.
7:02
and we can do that using Claude.
7:04
Our front-end changes are being written,
7:06
we're adding more tests, and we're adding some
7:08
formatting tools and development scripts for quality checks.
7:12
So we're going to proceed as expected,
7:13
making sure that quality scripts are being done,
7:16
and it looks like our front-end features are being added.
7:19
Now, add that light theme,
7:21
the same way that we did previously. We'll use our implement feature,
7:24
custom command to make sure we're writing that to our change log.
7:28
and we'll add a light theme as
7:29
well. Once that's done, we'll go ahead and
7:31
cue up a few other prompts we'd like
7:34
for JavaScript functionality and implementation details.
7:36
So while that's running, I can check in on other scripts.
7:39
I can confirm I want to run those,
7:41
and if there's something going on, Claude Code can fix per necessary.
7:45
Seems like there are some scripts that Claude doesn't know about,
7:48
so we'll go ahead and either install dependencies
7:50
or make sure we're running things as expected.
7:53
You can see here, we're starting from code quality checks.
7:55
We've written our API endpoint testing and we're adding more
7:59
front end functionality. Once this is all
8:01
done, we can head over to the browser.
8:03
We can confirm our checks are done,
8:04
but before we go ahead and do that,
8:07
let's bring in all of these individual changes.
8:09
If we wanted to run the tests,
8:11
we can confirm this is as expected.
8:13
We want to head to the browser
8:14
for our UI testing, we can do so.
8:16
And here we can see Codebase formatting is done, Development scripts have
8:19
been added, and documentation has been
8:21
updated. We saw before there was a
8:24
the pyproject.toml file that was added across two different worktrees.
8:27
So there might be some conflicts when figuring out these individual pieces.
8:31
Now that we feel good about each
8:33
of these changes, let's add and commit with a descriptive message.
8:37
Let's also do the same thing on this work tree.
8:39
Since we're going to be merging in these particular commits,
8:42
we're going to want to make sure we have descriptive commit messages
8:44
we can understand what was done in each of these worktrees.
8:47
We've committed this particular commit,
8:50
we're doing the same on this one right here.
8:52
We finished up our UI enhancement. So let's do the same.
8:55
add and commit with a descriptive message.
8:58
If you find yourself writing these kinds of
9:00
prompts like add and commit with a descriptive message,
9:02
this also could be another use case for
9:04
a nice custom command where we can specify
9:07
exactly some styling that we want or the
9:09
way that our company operates with best Git practices.
9:11
Now that I finished committing across all three of these,
9:14
I can now go back to my
9:16
main branch and merge some things in.
9:18
So I'm going to close these terminal
9:19
environments and hop back to our main one.
9:22
So now I'm going to ask Claude...
9:23
To use the Git merge command
9:26
to merge in all of the worktrees in the .trees folder
9:30
and fix any conflicts if there are any.
9:33
So let's have Claude Code merge all of these particular trees
9:37
and make sure that they work as expected.
9:39
We can see here there are three worktrees available.
9:41
So we're going to start by merging in each of these worktrees.
9:44
We'll confirm this is the command we want to use,
9:47
and then this should work as expected.
9:49
Looks like our testing feature doesn't have any conflicts.
9:52
Let's bring on our UI feature.
9:54
And again, we could write these commands on our own,
9:56
but Claude Code knows exactly what to do from our prompt.
9:59
Now we can merge in the quality feature branch.
10:01
And here we'll see if there are any conflicts.
10:04
and as we can see, in this particular file, there are conflicts.
10:08
So what we're going to have Claude Code do
10:10
is analyze these conflicts and complete the merge.
10:12
This can be quite valuable when you have small merge conflicts
10:15
that you don't want to manually go through each time.
10:18
Having tests here is also quite valuable
10:20
to make sure that once we've finished, we could
10:22
run our tests and the code base works as expected.
10:25
It's now continuing with the merge as expected.
10:27
and it's going to commit all of
10:29
these changes with the resolved merge conflicts.
10:31
If I'd like after, I can ask for it to remove
10:34
these worktrees or I can keep them there if I need.
10:36
So I'll do a quick test to
10:38
make sure that these files are here
10:40
as expected and that the merge configurations
10:41
are what are expected here as well.
10:43
We can also head back to the browser and
10:46
see if our front end changes are implemented as expected.
10:48
Looks like Claude Code has finished up, we've added necessary dependencies,
10:52
we've modified our pyproject.toml
10:54
We've added tests.
10:56
we've implemented the light dark themes.
10:58
We've implemented our black code formatter
11:01
to make sure that code is as expected in a certain format.
11:04
and added that configuration in the same file
11:06
that we worked on with another work tree.
11:09
We fixed up any conflicts.
11:11
Let's make sure this is working
11:12
as expected. So back in the browser,
11:14
I now see here, I have this lovely theme
11:17
and as I toggle through, I can
11:19
see a light theme and a dark theme.
11:21
So there might be some more things
11:22
I want to tweak here and there,
11:24
but I've been able to edit across all parts of the stack,
11:27
even do things in the linting and DevOps side of things,
11:32
all without overwriting,
11:34
causing challenging headaches through the power of Git worktrees.
11:37
In the next lesson, we're going to see how
11:40
we can use Claude Code outside of the terminal
11:42
through an integration with GitHub to allow for reviewing pull requests,
11:47
making changes and being helpful outside of the terminal ecosystem.